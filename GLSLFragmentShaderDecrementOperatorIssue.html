<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>GLSL Fragment Shader For Loop Issue</title>

<!--
Test to show issue with pre decrement operator
Only happens on Chrome Canary (25.0.1331.0) and Chrome stable (23.0.1271.64 m) with --use-gl=desktop
and on Firefox 17.0
  
 Author : Tibor den Ouden  
-->

<script>
<!-- Globals -->
	
gWebGL = null;


<!-- WebGL initialization -->

// Message when browser does not support WebGL
var NO_WEBGL_BROWSER = '<a href="http://get.webgl.org">This page requires a browser that supports WebGL.</a>';


// Message when computer does not support WebGL
var NO_WEBGL_CONTEXT = '<a href="http://get.webgl.org/troubleshooting/">This computer does not support WebGL.</a>';


// Creates html code which contains a message
function CreateMessageHTML(inMsg) {
  return '' +
    '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
    '<td align="center">' +
    '<div style="display: table-cell; vertical-align: middle;">' +
    '<div style="">' + inMsg + '</div>' +
    '</div>' +
    '</td></tr></table>';
};


// Show the message in the page
function ShowMessage(inMsg, inCanvas) {
    var container = inCanvas.parentNode;
    if (container) {
    	container.innerHTML = CreateMessageHTML(inMsg);
    }
};

    
// Returns the webgl attributes with default values    
function GetDefaultWebGLAttributes() {
	return {
    	alpha:                 true,
    	depth:                 true,
    	stencil:               false,
    	antialias:             true,
    	premultipliedAlpha:    true,
    	preserveDrawingBuffer: false,
	};
}


// Return a WebGL context from the canvas element
function InitWebGL(inCanvas, inWglAttributes) {
    // Check if browser supports WebGL
   	if (!window.WebGLRenderingContext) {
    	ShowMessage(NO_WEBGL_BROWSER, inCanvas);
        return null;
   	}

	// Iterate over valid 3D context names
	var context_names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
	var wgl_context = null;
	for (var n_ix = 0; n_ix < context_names.length; ++n_ix) {
		try {
			wgl_context = inCanvas.getContext(context_names[n_ix], inWglAttributes);
		} 
		catch(inException) {
		}
		
		if (wgl_context != null) 
			break;
	}
  
    if (wgl_context == null) {
    	ShowMessage(NO_WEBGL_CONTEXT, inCanvas);
    }

	return wgl_context;
}

 
<!-- Utility functions for test -->


// Create a texture which contains floating point data
function CreateFloatingPointTexture(inData, inWidth, inHeight) {
	// Create the texture		
	var texture_handle = gWebGL.createTexture();

	// Make texture active	
  	gWebGL.bindTexture(gWebGL.TEXTURE_2D, texture_handle);
  	
  	// Set size and contents of texture 
  	gWebGL.pixelStorei(gWebGL.UNPACK_ALIGNMENT, 4);
  	gWebGL.pixelStorei(gWebGL.UNPACK_FLIP_Y_WEBGL, 0);
  	gWebGL.pixelStorei(gWebGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, this.NONE);
  	gWebGL.pixelStorei(gWebGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);

  	// Set the parameters 
  	gWebGL.texParameteri(gWebGL.TEXTURE_2D, gWebGL.TEXTURE_WRAP_S, 	   gWebGL.CLAMP_TO_EDGE); 
  	gWebGL.texParameteri(gWebGL.TEXTURE_2D, gWebGL.TEXTURE_WRAP_T, 	   gWebGL.CLAMP_TO_EDGE);
  	gWebGL.texParameteri(gWebGL.TEXTURE_2D, gWebGL.TEXTURE_MIN_FILTER, gWebGL.NEAREST);
  	gWebGL.texParameteri(gWebGL.TEXTURE_2D, gWebGL.TEXTURE_MAG_FILTER, gWebGL.NEAREST);
  	
    gWebGL.texImage2D(gWebGL.TEXTURE_2D, 0, gWebGL.RGBA, inWidth, inHeight, 0, gWebGL.RGBA, gWebGL.FLOAT, (inData.length == 0) ? null : inData);
    
    var error = gWebGL.getError();
    if (error != gWebGL.NONE)
    	alert("Error while creating texture : 0x" + error.toString(16)); 

	gWebGL.bindTexture(gWebGL.TEXTURE_2D, null);

	return texture_handle;	
}

 
function CreateShader(inSource, inType) {
 	var handle = gWebGL.createShader(inType);
 	
 	gWebGL.shaderSource(handle, inSource);
 	gWebGL.compileShader(handle);

    // Check the compile status
    var compiled = gWebGL.getShaderParameter(handle, gWebGL.COMPILE_STATUS);
    if (!compiled && !gWebGL.isContextLost()) {
        // Retrieve info
        var error_text = gWebGL.getShaderInfoLog(handle);
        alert("Error compiling shader : " + error_text);
        
        gWebGL.deleteShader(handle);
        handle = null;
    }

	return handle;	
}


// Utility function to create a valid string representation of a floating point number
function MakeFloatRepString(inValue) {
	var str = "" + inValue;
	if (str.indexOf(".") == -1)
	{
		// Value was an integer, so no decimal point is printed, add one
		str += ".0";
	}
		
	return str;
}


function CreateShaderProgram(inDecr) {
	// Vertex shader
 	var vx_source = [
		// Inputs
		"attribute vec4 a_position;         ",
		"attribute vec2 a_tex_coords;       ",
		
		// Outputs
		"varying vec2 v_tex_coords;         ",
		
		"void main(void) {                  ",
		"    v_tex_coords = a_tex_coords;   ",
		"    gl_Position  = a_position;     ",
		"}                                  "
 	];

	vx_handle = CreateShader(vx_source.join("\n"), gWebGL.VERTEX_SHADER);
	
	// Fragment shader
	var fx_common_source = [
		// Input
		"varying mediump vec2 v_tex_coords; ",
		
		// Constants
		"const mediump float TEX_HEIGHT = " + MakeFloatRepString(gWebGL.drawingBufferHeight + 0.5) + "; ",

		 
		"void main(void) {                 ",
		"    mediump float tex_ix = floor(v_tex_coords.y * TEX_HEIGHT); ",

 		"    mediump float pre_dec_tex_ix  = tex_ix; ", 
		"    mediump float post_dec_tex_ix = tex_ix; ",
		"    mediump float sub_tex_ix      = tex_ix; "
	];

	var fx_decr_source = [		
		"    --pre_dec_tex_ix; ",
		"    post_dec_tex_ix--; ",
		"    sub_tex_ix -= 1.0; "
	];

	var fx_incr_source = [ 
		"    ++pre_dec_tex_ix; ",
		"    post_dec_tex_ix++; ",
		"    sub_tex_ix += 1.0; ",
	];

	var fx_finish_source = [
		"    gl_FragColor = vec4(tex_ix/255.0, (pre_dec_tex_ix + 100.0)/255.0, post_dec_tex_ix/255.0, sub_tex_ix/255.0); ",
		"} ",
	];
	 	
	var fx_source;
	
	if (inDecr) 
		fx_source = fx_common_source.concat(fx_decr_source, fx_finish_source);	
	else
		fx_source = fx_common_source.concat(fx_incr_source, fx_finish_source);
		
	
	fx_handle = CreateShader(fx_source.join("\n"), gWebGL.FRAGMENT_SHADER);
	
    // Create the shader program object
    var prg_handle = gWebGL.createProgram();

    gWebGL.attachShader(prg_handle, vx_handle);
    gWebGL.attachShader(prg_handle, fx_handle);

    // Link the program
    gWebGL.linkProgram(prg_handle);

    // Check the link status
    var linked = gWebGL.getProgramParameter(prg_handle, gWebGL.LINK_STATUS);
    
    if (!linked && !gWebGL.isContextLost()) {
        var error_text = WebGL.getProgramInfoLog (prg_handle);
        alert("Error in linking : " + error_text);

        wgl_ctx.deleteProgram(prg_handle);
		prg_handle = null;
    }
	
	return prg_handle;
}


// Utility function to set an integer uniform
function Setter1Int(inLocation, inValue) {
	gWebGL.uniform1i(inLocation, inValue);
}


function BindAndSetUniform(inName, inSetter, inValue, inProgramHandle) {
	var location = gWebGL.getUniformLocation(inProgramHandle, inName);
	
 	if (location == null) {
 		alert("Uniform : " + inName  + " not found");
 		return;
 	}
 	
 	inSetter(location, inValue);
}


function CreateDataBuffer(inData, inUsage, inGroupCount) {
	
	// Create buffer
	var buffer_handle = gWebGL.createBuffer();	
    
    // Make buffer active
    gWebGL.bindBuffer(gWebGL.ARRAY_BUFFER, buffer_handle);
	
	// Load data in buffer
    gWebGL.bufferData(gWebGL.ARRAY_BUFFER, inData, inUsage);
	buffer_handle.mGroupCount  = inGroupCount;
			
	// Store item count with the buffer
	buffer_handle.mLength = inData.length / inGroupCount;
				
   	gWebGL.bindBuffer(gWebGL.ARRAY_BUFFER, null);

	return buffer_handle;
}


function CreateFrameBufferAttributeData() {
	// Create frame buffer coordinates which cover complete frame buffer
	var complete_frame_buf_coords = [
		 1.0,  1.0, 0.0, 1.0, // Right top
		-1.0,  1.0, 0.0, 1.0, // Left  top
		 1.0, -1.0, 0.0, 1.0, // Right bottom

		-1.0,  1.0, 0.0, 1.0, // Left  top
		-1.0, -1.0, 0.0, 1.0, // Left  bottom
		 1.0, -1.0, 0.0, 1.0  // Right bottom
	];
	
	return CreateDataBuffer(new Float32Array(complete_frame_buf_coords), gWebGL.STATIC_DRAW, 4);
}


function CreateTextureAttributeData() {
	// Create texture coordinates which cover complete texture
	var complete_tex_coords = [
		1.0, 1.0, // Right top
		0.0, 1.0, // Left  top
		1.0, 0.0, // Right bottom
		 
		0.0, 1.0, // Left  top
		0.0, 0.0,  // Left  bottom
		1.0, 0.0  // Right bottom
	];

	return CreateDataBuffer(new Float32Array(complete_tex_coords), gWebGL.STATIC_DRAW, 2);
}


function BindAttribute(inName, inData, inProgram) {
	// Bind attribute 
 	var location = gWebGL.getAttribLocation(inProgram, inName);
 	
 	if (location == null) {
 		alert("Attribute : " + inName + " not found");
 		return;
 	}
 	
	// Enable attribute index
    gWebGL.enableVertexAttribArray(location);
    
    // Bind data
    gWebGL.bindBuffer(gWebGL.ARRAY_BUFFER, inData);

	// Interpret data
	// Args : attribute ix, component count, type, normalized, stride (bytes), offset (bytes)
    gWebGL.vertexAttribPointer(location, inData.mGroupCount, gWebGL.FLOAT, false, 0, 0);
}


function BindTexture(inUniform, inTextureHandle, inShaderUnit, inProgramHandle) {

 	// Bind texture
	// Make texture unit 0 active
	gWebGL.activeTexture(gWebGL.TEXTURE0 + inShaderUnit);

	// Set texture
	gWebGL.bindTexture(gWebGL.TEXTURE_2D, inTextureHandle);

	// Bind texture unit to shader
 	BindAndSetUniform(inUniform, Setter1Int, inShaderUnit, inProgramHandle);

}
 
 // Read data from the color channels of the frame buffer
// Values are returned in range : [0 .. 255]
function ReadFrameBufferData() {
	var width  = gWebGL.drawingBufferWidth;
	var height = gWebGL.drawingBufferHeight;
	var color_channel_count = 4;  // RGBA
   	var read_data = new Uint8Array(color_channel_count * width * height);
   	gWebGL.readPixels(0, 0, width, height, gWebGL.RGBA, gWebGL.UNSIGNED_BYTE, read_data);
   	
   	return read_data;
}


// Print value right aligned 
function ValueToString(inValue, inFieldLength) {
	var str = "" + inValue;
	var prefix_count = inFieldLength - str.length;
	
	if (prefix_count > 0) {
		var prefix = "";
		for (var p_ix = 0; p_ix < prefix_count; ++p_ix)
			prefix += " ";
			
		return prefix + str;
	}
	else
		return str;
}


function PrintPixels(inOutputElement, inHorPixelCount, inVerPixelCount) {
	// Read data
	var framebuffer_data = ReadFrameBufferData();

	var channel_count    = 4;
	var field_length     = 4;
	var hor_pixel_stride = gWebGL.drawingBufferWidth;
	
	var v_ix = 0;
	for (var vp_ix = 0; vp_ix < inVerPixelCount; ++vp_ix) { 
		for (var hp_ix = 0; hp_ix < inHorPixelCount; ++hp_ix) {
			for (var c_ix = 0; c_ix < channel_count; ++c_ix) 
				inOutputElement.value += ValueToString(framebuffer_data[v_ix++], field_length);
			
			inOutputElement.value += "     ";	
		}
		inOutputElement.value += "\n";
		
		v_ix += (hor_pixel_stride - inHorPixelCount) * channel_count; 
	}	
}


<!-- Run the test -->

function RunTest(inShowDecrResults) {
	if (gWebGL == null) {
		alert("WebGL context not defined !");
		return;
	}

	document.getElementById("TestOutput").value = "Show results for " + (inShowDecrResults ? "decrement" : "increment") + " test\n";
	
	var shader_program    = CreateShaderProgram(inShowDecrResults);
	var fb_attribute_data = CreateFrameBufferAttributeData();
	var tx_attribute_data =	CreateTextureAttributeData();
	
	// Activate the program
	gWebGL.useProgram(shader_program);

	// Bind attributes	
	BindAttribute("a_position",   fb_attribute_data, shader_program);
	BindAttribute("a_tex_coords", tx_attribute_data, shader_program);
 	
	// Render triangles
	gWebGL.drawArrays(gWebGL.TRIANGLES, 0, fb_attribute_data.mLength);
	
	// Output
	// PrintPixels(inOutputElement, inHorPixelCount, inVerPixelCount)
	PrintPixels(document.getElementById("TestOutput"), 4, 20);
	
	// Disable
}


<!-- OnLoad -->

function OnLoad() {
    // Test if WebGL element is on the page
    var webgl_element = document.getElementById("ViewPort");
    if (webgl_element == null) {
        return;
    }

	// Set construction attributes
	var web_gl_attr = GetDefaultWebGLAttributes();
	web_gl_attr.depth     = false;
	web_gl_attr.antialias = false;
	
    // Try to create the WebGL context
    gWebGL = InitWebGL(webgl_element, web_gl_attr);
    
    if (gWebGL == null)
    	return;
    	
    gWebGL.viewport(0, 0, gWebGL.drawingBufferWidth, gWebGL.drawingBufferHeight);
    
    // Test for floating point texture extension 
    if (!gWebGL.getExtension("OES_texture_float"))
    	alert("No support for OES_texture_float");

    // Output window contains some spaces already ?!
	var test_output = document.getElementById("TestOutput");
	// test_output.value = "Viewport : " + gWebGL.drawingBufferWidth + " x " + gWebGL.drawingBufferHeight + "\n";
}

</script>

<style type="text/css">
.view_port
{
	border: 1px solid black;
}

</style>
</head>


<!-- Body of page -->
<body onload="OnLoad()">
    <div class="Container">
        <div>
            <!-- The canvas object -->
            <canvas id="ViewPort" class="view_port" width="64px" height="32px">
                If you're seeing this, your web browser doesn't support the &lt;canvas>&gt; element. :-(
            </canvas>
        </div>

        <div>
            <ol>
                <li><button class="Button" onclick=RunTest(true)  title="Run decrement shader">Run decrement test</button></li> 
                <li><button class="Button" onclick=RunTest(false) title="Run increment shader">Run increment test</button></li> 
            </ol>
        </div>
        
        <div>
            <textarea id="TestOutput" rows="30" cols = "150">
            </textarea>
        </div>
        
    </div>
</body>

</html>
